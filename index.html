<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="theme-color" content="#000000" />
    <link rel="manifest" href="manifest.json" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <title>나의 대동여지도</title>
    <style>
        #map { height: 100vh; margin: 0; padding: 0; }
        body { margin: 0; font-family: sans-serif; background: #000; }
    </style>
</head>
<body>
    <div id="map"></div>

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script>
        const map = L.map('map').setView([37.5665, 126.9780], 15);

        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '&copy; OpenStreetMap, CartoDB',
        }).addTo(map);

        let path = [];
        let polyline; // Polyline 객체를 저장할 변수
        let polylines = []; // 날짜별 경로를 저장할 배열
        const DAY_IN_MS = 1000 * 60 * 60 * 24;

        function getOpacityByDays(days) {
            if (days <= 1) return 1.0;
@@ -35,65 +36,81 @@
        }

        function drawPath() {
            // 기존 경로 삭제
            if (polyline) {
                map.removeLayer(polyline);
            }
            // 기존 경로 모두 삭제
            polylines.forEach(polyline => map.removeLayer(polyline));
            polylines = [];
            
            const now = Date.now();
            let currentPath = [];
            let prevTimestamp = null;

            const latlngs = [];
            const opacities = [];
            for (let i = 0; i < path.length; i++) {
                const { latlng, timestamp } = path[i];
                const now = Date.now();
                const daysAgo = (now - timestamp) / (1000 * 60 * 60 * 24);
                const daysAgo = (now - timestamp) / DAY_IN_MS;
                const opacity = getOpacityByDays(daysAgo);
                latlngs.push(latlng);
                opacities.push(opacity);

                // 날짜가 바뀌면 새로운 경로 시작
                if (prevTimestamp === null || Math.floor((timestamp - (new Date(timestamp)).setHours(0,0,0,0)) / DAY_IN_MS) !== Math.floor((prevTimestamp - (new Date(prevTimestamp)).setHours(0,0,0,0)) / DAY_IN_MS)) {
                    if (currentPath.length > 1) {
                        const polyline = L.polyline(currentPath, {
                            color: '#00ffcc',
                            opacity: getOpacityByDays((now - currentPath[0].timestamp) / DAY_IN_MS), // 시작점 기준으로 opacity 계산
                            weight: 4,
                            lineCap: 'round',
                            
                        }).addTo(map);
                        polylines.push(polyline);
                    }
                    currentPath = [];
                }
                
                currentPath.push({latlng, timestamp});
                prevTimestamp = timestamp;
            }

            // 경로를 그릴 때, 각 segment의 opacity를 배열로 전달할 수 없으므로,
            // 전체 경로를 하나의 polyline으로 그리고, 각 점의 opacity를 별도로 관리하지 않습니다.
            polyline = L.polyline(latlngs, {
                color: '#00ffcc',
                opacity: opacities[0] || 1, // 첫 번째 opacity를 사용하거나, 없을 경우 1로 설정
                weight: 4,
                lineCap: 'round', // 부드러운 선 끝
                dashArray: '5, 10' // 점선 스타일 (선택 사항)
            }).addTo(map);
            // 마지막 경로 그리기
            if (currentPath.length > 1) {
                 const polyline = L.polyline(currentPath, {
                    color: '#00ffcc',
                    opacity: getOpacityByDays((now - currentPath[0].timestamp) / DAY_IN_MS),
                    weight: 4,
                    lineCap: 'round',
                }).addTo(map);
                polylines.push(polyline);
            }

             // 마지막 위치에 마커 추가
             if (latlngs.length > 0) {
                L.marker(latlngs[latlngs.length - 1]).addTo(map);
            // 마지막 위치에 마커 추가
            if (path.length > 0) {
                L.marker(path[path.length - 1].latlng).addTo(map);
            }
        }

        function onLocationFound(e) {
            const latlng = [e.latitude || e.latlng.lat, e.longitude || e.latlng.lng];
            const timestamp = Date.now();
            path.push({ latlng, timestamp });

            drawPath(); // 경로 갱신
            drawPath();
        }

        function onLocationError(e) {
            alert("위치 정보를 가져올 수 없습니다: " + e.message);
        }

        map.locate({ setView: true, maxZoom: 16, watch: true });
        map.on('locationfound', onLocationFound);
        map.on('locationerror', onLocationError);
    </script>

    <script>
        // PWA service worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('sw.js').then(reg => {
                    console.log('Service Worker 등록 성공:', reg);
                }).catch(err => {
                    console.log('Service Worker 등록 실패:', err);
                });
            });
        }
    </script>
</body>
